#! python

import argparse
import logging
import os
import re
import shutil
import subprocess
import sys
from time import sleep
from subprocess import Popen, PIPE

# default input files
ENV_FILE='kubeflow.env'
ENV_FILE_TEMPLATE='kubeflow.tmpl.env'
KUBEFLOW_VERSION_FILE='kubeflow_version.env'

# variable example and pattern for validation
variable_specs = {
    'OCI_KUBEFLOW_DOMAIN_NAME': {
        'example': 'mydomain.com',
        'pattern': r'[a-z0-9.]+'
    },
    'OCI_KUBEFLOW_DOMAIN_ADMIN_EMAIL': {
        'example': 'admin@mydomain.com',
        'pattern': None
    },
    'OCI_KUBEFLOW_DNS_ZONE_COMPARTMENT_OCID': {
        'example': 'ocid1.compartment.oc1...',
        'pattern': r'ocid1\.compartment\.oc.*'
    },
    'OCI_KUBEFLOW_IDCS_URL': {
        'example': 'https://idcs-xxxxxx.identity.oraclecloud.com',
        'pattern': r'https://idcs-.*\.identity.oraclecloud.com$'
    },
    'OCI_KUBEFLOW_IDCS_CLIENT_ID': {
        'example': 'e140ade85eec47748df546d3ba6aeca8',
        'pattern': r'[a-f0-9]{32}'
    },
    'OCI_KUBEFLOW_IDCS_CLIENT_SECRET': {
        'example': '0943f5de-eae2-4a68-c9db-d5380fe933b4',
        'pattern': r'[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}'
    },
    'OCI_KUBEFLOW_MYSQL_USER': {
        'example': 'kubeflow',
        'pattern': r'[a-zA-Z0-9_]+'
    },
    'OCI_KUBEFLOW_MYSQL_PASSWORD': {
        'example': '',
        'pattern': None
    },
    'OCI_KUBEFLOW_MYSQL_HOST': {
        'example': '',
        'pattern': r'.*\.oraclevcn.com'
    },
    'OCI_KUBEFLOW_MYSQL_PORT': {
        'example': '3306',
        'pattern': r'3306'
    },
    'OCI_KUBEFLOW_OBJECT_STORAGE_REGION': {
        'example': 'us-ashburn-1',
        'pattern': r'[a-z]{2}-[a-z]+-[0-9]+'
    },
    'OCI_KUBEFLOW_OBJECT_STORAGE_BUCKET': {
        'example': 'name-kubeflow-metadata',
        'pattern': r'[a-zA-Z0-9_-]+'
    },
    'OCI_KUBEFLOW_OBJECT_STORAGE_NAMESPACE': {
        'example': 'mynamespace',
        'pattern': r'[a-zA-Z0-9_-]+'
    },
    'OCI_KUBEFLOW_OBJECT_STORAGE_ACCESS_KEY': {
        'example': '5cc417c90231c7dc02a9cd90e6f6ac301e46c282',
        'pattern': r'[a-f0-9]{40}'
    },
    'OCI_KUBEFLOW_OBJECT_STORAGE_SECRET_KEY': {
        'example': 'sdwAAerQWE123fre3245SDFEw334=',
        'pattern': r'[a-zA-Z0-9+=]+'
    }
}
# variables required by each add-on
add_on_variables = {
    'letsencrypt-http01': [
        'OCI_KUBEFLOW_DOMAIN_NAME',
        'OCI_KUBEFLOW_DOMAIN_ADMIN_EMAIL'
    ],
    'letsencrypt-dns01': [
        'OCI_KUBEFLOW_DOMAIN_NAME',
        'OCI_KUBEFLOW_DOMAIN_ADMIN_EMAIL',
        'OCI_KUBEFLOW_DNS_ZONE_COMPARTMENT_OCID'
    ],
    'idcs': [
        'OCI_KUBEFLOW_IDCS_URL',
        'OCI_KUBEFLOW_IDCS_CLIENT_ID',
        'OCI_KUBEFLOW_IDCS_CLIENT_SECRET'
    ],
    'external-mysql': [
        'OCI_KUBEFLOW_MYSQL_USER',
        'OCI_KUBEFLOW_MYSQL_PASSWORD',
        'OCI_KUBEFLOW_MYSQL_HOST',
        'OCI_KUBEFLOW_MYSQL_PORT'
    ],
    'oci-object-storage': [
        'OCI_KUBEFLOW_OBJECT_STORAGE_REGION',
        'OCI_KUBEFLOW_OBJECT_STORAGE_BUCKET',
        'OCI_KUBEFLOW_OBJECT_STORAGE_NAMESPACE',
        'OCI_KUBEFLOW_OBJECT_STORAGE_ACCESS_KEY',
        'OCI_KUBEFLOW_OBJECT_STORAGE_SECRET_KEY'
    ]
}


log = logging.getLogger(__file__)
formatter = logging.Formatter('[%(asctime)s][%(levelname)-7s] %(message)s')
handler = logging.StreamHandler(sys.stdout)
handler.setFormatter(formatter)
log.addHandler(handler)

no_prompts = False

def parse_versions_file():
    versions = {}
    with open(KUBEFLOW_VERSION_FILE, 'r') as f:
        kf_version_file_content = f.readlines()
        for line in kf_version_file_content:
            if line[0] != '#':
                k, v = line.strip().split('=', 1)
                versions[k] = v.replace('"','')
    return versions


def parse_kubeflow_env(env_file=ENV_FILE):
    cwd = os.getcwd()
    env = {}
    with open(os.path.join(cwd, env_file), 'r') as f:
        config = f.readlines()
        for line in config:
            line=line.strip()
            if len(line) > 0 and line[0] != '#':
                log.debug(line)
                k, v = line.strip().split('=', 1)
                env[k] = v.replace('"', '')
    return env


def get_upstream(kf_version):
    # save currnet path
    cwd = os.getcwd()
    log.info(f'KubeFlow version {kf_version} installation checks.')
    upstream_dir = os.path.join(cwd, 'upstream')
    if os.path.exists(upstream_dir):
        os.chdir(upstream_dir)
        tags = subprocess.check_output('git describe --tags', shell=True)
        current_version = tags.decode('utf-8').strip()
        log.info(f'Upstream for version {current_version} found.')
        os.chdir(cwd)
        if current_version != kf_version:
            log.info('Version mismatch')
            shutil.rmtree(upstream_dir)
    if not os.path.exists(upstream_dir):
        log.info(f'Fetching KubeFlow {kf_version} ...')
        output = subprocess.check_output(f'git clone -c advice.detachedHead=false --branch {kf_version} \
            https://github.com/kubeflow/manifests.git --single-branch upstream', shell=True)
        log.info(output.decode('utf-8'))


def validate_kubectl():
    try:
        subprocess.check_output('command -v kubectl &>/dev/null', shell=True)
        log.info('kubectl found.')
    except subprocess.CalledProcessError as e:
        raise ValueError('error looking for kubectl')


def validate_kustomize():
    try:
        output = subprocess.check_output('kustomize version --short', shell=True)
        match = re.search(r'(\d+\.\d+\.\d+)', output.decode('utf-8'))
        if match:
            version = match.group(0)
            major, minor, _ = version.split('.')
            if not (int(major) >= 3 and int(minor) >= 6):
                raise ValueError(f'kustomize v{version} is too old. Setup requires v3.6+')
            else:
                log.info(f'kustomize v{version} found.')
    except subprocess.CalledProcessError as e:
        log.error('kustomize not found')
        exit(1)


def validate_oci_cli():
    try:
        subprocess.check_output('command -v oci &>/dev/null', shell=True)
        log.info('oci cli found.')
    except subprocess.CalledProcessError as e:
        raise ValueError('error looking for the oci cli')


def validate_env_variable(env, env_template, variable, example, pattern, no_prompts):
    if variable not in env_template.keys():
        raise ValueError(f'{variable} is not a recognized variable.')
    val = env.get(variable)
    val_orig = val
    while val is None or val == '':
        if no_prompts:
            raise ValueError(f'{variable} is not defined. Edit the env file or run the "okf config" command to configure missing variables.')
        val = input(f'{variable} is not defined. Please enter a value: \n> ')
        val = val.strip()
        
        if pattern is not None:
            log.debug(re.match(pattern, val))
            if re.match(pattern, val) is None:
                log.error(f'{val} does not match the required pattern "{pattern}", for example: {example}')
                val = ''
    if pattern is not None and re.match(pattern, val) is None:
        log.warning(f'{val} does not match the pattern "{pattern}"')
    if val != val_orig:
        env[variable] = val.strip()
        save_variable(variable, val)


def save_variable(variable, val):
    log.debug(f'Saving: {variable}')
    cwd = os.getcwd()
    content = None
    with open(os.path.join(cwd, env_file), 'r') as f:
        content = f.readlines()
    match_found = False
    for i in range(len(content)):
        line = content[i].strip()
        log.debug(line)
        pattern = r'' + variable + '=(.*)'
        # log.debug(pattern)
        match = re.match(pattern, line)
        if match is not None:
            log.debug(f'found {match.groups()}')
            content[i] = f'{variable}="{val}"\n'
            match_found = True
    if not match_found:
        # add to file
        content.append(f'{variable}="{val}"\n')
    if content is not None:
        with open(os.path.join(cwd, env_file), 'w') as f:
            f.writelines(content)
    

def get_add_ons():
    cwd = os.getcwd()
    add_ons = []
    with open(os.path.join(cwd, 'deployments', 'overlays', 'kustomization.yaml'), 'r') as f:
        add_ons_content = f.readlines()
        for line in add_ons_content:
            line=line.strip()
            if len(line) > 0 and line[0] != '#' and 'add-ons' in line:
                add_on_name = line.split('/')[2]
                add_ons.append(add_on_name)
    return add_ons


def validate_addons_config(add_ons, env_file, env, env_template, no_prompts):
    log.info(f'Checking configuration set in "{env_file}":')
    for add_on in add_ons:
        log.info(f'- {add_on} add-on:')
        if add_on in add_on_variables.keys():
            variables_to_check = add_on_variables.get(add_on)
            log.debug(variables_to_check)
            for variable in variables_to_check:
                specs = variable_specs.get(variable, {})
                log.debug(specs)
                validate_env_variable(env, env_template, variable, specs.get('example'), specs.get('pattern', None), no_prompts)
        else:
            log.warning(f'!!! {add_on} has no variables or is not recognized')
        log.info(f'  OK: variables are configured and matching patterns')


def render_template(env, template_file, rendered_path=None):
    cwd = os.getcwd()
    template_path = template_file.split('/')
    if rendered_path is None:
        rendered_path = os.sep.join(re.sub(r'.tmpl', '', template_file).split("/"))
        rendered_path = os.path.join(cwd, *rendered_path)
    log.info(f'Created file: {rendered_path}')
    template = None
    with open(os.path.join(cwd, *template_path), 'r') as f:
        template = f.readlines()
    if template is not None:
        for i in range(len(template)):
            for env_var in env.keys():
                template[i] = re.sub(r'\$[{]?' + env_var + '[}]?', env.get(env_var), template[i])
                template[i] = re.sub(r'\\\"', '"', template[i])
    for line in template:
        log.debug(f'                {line.rstrip()}')
    with open(rendered_path, 'w') as f:
        f.writelines(template)


def get_lb_ip():
    # Get load balancer IP
    cmd = 'kubectl get svc istio-ingressgateway -n istio-system -o=jsonpath="{.status.loadBalancer.ingress[0].ip}"'
    try:
        lb_ip=subprocess.check_output(cmd, shell=True).decode('utf-8')
    except subprocess.CalledProcessError as e:
        lb_ip=''
    return lb_ip


def setup_idcs(env, deferred_run=False):
    domain_name = env.get('OCI_KUBEFLOW_DOMAIN_NAME', '')
    issuer = ''
    if domain_name == '':
        lb_ip = get_lb_ip()
        if lb_ip == '':
            log.warning('Without setting up a domain name, IDCS can only be configured with the load balancer IP adress,')
            log.warning('however the IP is only available after deployment, so this process will be deferred')
        else:
            log.debug(f"Load Balancer IP: {lb_ip}")
        issuer = lb_ip
    else:
        issuer = domain_name
    if issuer == '':
        issuer = 'dex.auth.svc.cluster.local:5556'
        env['OCI_KUBEFLOW_ISSUER']=f"http://{issuer}/dex"
        render_template(env, 'oci/common/dex/overlays/idcs/config.tmpl.yaml')
        render_template(env, 'oci/common/oidc-authservice/overlays/idcs/params.tmpl.env')
        return True # defer this action
    else:
        env['OCI_KUBEFLOW_ISSUER']=f"https://{issuer}/dex"
        render_template(env, 'oci/common/dex/overlays/idcs/config.tmpl.yaml')
        render_template(env, 'oci/common/oidc-authservice/overlays/idcs/params.tmpl.env')
        return False


def setup_letsencrypt(env):
    render_template(env, 'oci/common/istio/kubeflow-istio-resources/overlays/letsencrypt-http01/kubeflow-gw.Certificate.tmpl.yaml')
    render_template(env, 'oci/common/istio/kubeflow-istio-resources/overlays/letsencrypt-http01/letsencrypt.ClusterIssuer.tmpl.yaml')
    render_template(env, 'oci/common/istio/kubeflow-istio-resources/overlays/letsencrypt-dns01/kubeflow-gw.Certificate.tmpl.yaml')
    render_template(env, 'oci/common/istio/kubeflow-istio-resources/overlays/letsencrypt-dns01/letsencrypt.ClusterIssuer.tmpl.yaml')
    render_template(env, 'oci/apps/kserve/domain/config-domain.tmpl.yaml')


def setup_oci_object_storage(env):
    render_template(env, 'oci/apps/pipeline/oci-object-storage/config.tmpl')
    render_template(env, 'oci/apps/pipeline/oci-object-storage/minio.tmpl.env')
    render_template(env, 'oci/apps/pipeline/oci-object-storage/params.tmpl.env')


def setup_mysql(env):
   render_template(env, 'oci/apps/pipeline/mds-external-mysql/mysql.tmpl.env')
   render_template(env, 'oci/apps/pipeline/mds-external-mysql/mysql.Service.tmpl.yaml')


def setup_dns_zone(env):
    domain_name = env.get('OCI_KUBEFLOW_DOMAIN_NAME')
    dns_zone_compartment_id = env.get('OCI_KUBEFLOW_DNS_ZONE_COMPARTMENT_OCID')
    try:
        cmd = f'oci dns zone get --zone-name-or-id {domain_name}'
        subprocess.check_output(cmd, shell=True)
        log.info(f'DNS Zone is configured for domain "{domain_name}"')
    except subprocess.CalledProcessError:
        try:
            subprocess.check_output(f'oci dns zone create --compartment-id {dns_zone_compartment_id} --name {domain_name} --zone-type PRIMARY', shell=True)
            log.info(f'Please enter the nameservers above at the provider for the domain {domain_name}')
        except subprocess.CalledProcessError:
            raise ValueError('enable to create the DNS Zone')


def setup_dns_post_deploy(env):
    lb_ip = ''
    trial_count = 60  # try up to 10min
    while lb_ip == '' and trial_count > 0:
        lb_ip = get_lb_ip()
        if lb_ip == '':
            sleep(10)
            trial_count -= 1
    if lb_ip == '':
        raise ValueError('Could not retrieve Load Balancer IP adress')
    
    domain_name = env.get('OCI_KUBEFLOW_DOMAIN_NAME')
    try:
        log.info(f'DNS setup: set A record with load balancer IP {lb_ip} for {domain_name}')
        # Set the A record pointing to the Load Balancer IP
        cmd = f'oci dns record rrset update --force --domain {domain_name} --zone-name-or-id {domain_name} --rtype "A" --items \'[{{"domain":"{domain_name}", "rdata":"{lb_ip}", "rtype": "A", "ttl":300}}]\''
        output = subprocess.check_output(cmd, shell=True)
        # log.info(output.decode('utf-8'))
    except subprocess.CalledProcessError:
        raise ValueError('Enable to set load balancer IP on DNS')
    try:
        log.info(f'DNS setup: set CNAME record for wildcard sub-domain *.{domain_name}')
        # Set the CNAME record pointing wildcard subdomains to the root domain
        cmd = f'oci dns record rrset update --force --domain "*.{domain_name}" --zone-name-or-id {domain_name} --rtype "CNAME" --items \'[{{"domain": "*.{domain_name}", "rdata": "{domain_name}", "rtype": "CNAME", "ttl":300}}]\''
        output = subprocess.check_output(cmd, shell=True)
        # log.info(output.decode('utf-8'))
    except subprocess.CalledProcessError:
        raise ValueError('Enable to set CNAME record on DNS')


def run_shell_cmd(cmd):
    log.debug(cmd)
    p = Popen(cmd, stdout=PIPE, stderr=PIPE)
    while p.poll() is None:
        line = p.stdout.readline()
        log.info(line.decode('utf-8').rstrip())


def kustomize_manifests(output):
    cwd = os.getcwd()
    overlay_path = os.path.join(cwd, 'deployments', 'overlays')
    if output is not None:
        manifest_path = os.path.join(cwd, *output.split(os.sep))
        log.info(f'Generating manifests to {overlay_path}. This may take a few minutes...')
        cmd = f'kustomize build {overlay_path} -o {manifest_path}'.split() 
        run_shell_cmd(cmd)


def kustomize_and_apply():
    cwd = os.getcwd()
    overlay_path = os.path.join(cwd, 'deployments', 'overlays')
    ready = False
    while not ready:
        try:
            log.info(f'Generating manifests and deploying. This may take a few minutes...')
            cmd = f'kustomize build {overlay_path}'.split()
            cmd2 = 'kubectl apply -f -'.split()
            log.debug(cmd)
            log.debug(cmd2)
            p = Popen(cmd, stdout=PIPE, stderr=PIPE)
            p2 = Popen(cmd2, stdin=p.stdout, stdout=PIPE, stderr=PIPE)
            while p2.poll() is None:
                line = p2.stdout.readline()
                log.info(line.decode('utf-8').rstrip())
            retcode = p.poll()
            if retcode == 0:
                ready = True
        except Exception as e:
            log.error(e)
    

# def apply_manifests(input_path):
#     cwd = os.getcwd()
#     manifests_path = os.path.join(cwd, input_path)
#     while not ready:
#         try:
#             cmd = f'kubectl apply -f {manifests_path}'.split()
#             log.debug(cmd)
#             p = Popen(cmd, stdout=PIPE, stderr=PIPE)
#             while p.poll() is None:
#                 line = p.stdout.readline()
#                 log.info(line.decode('utf-8').rstrip())
#             retcode = p.poll()
#             if retcode == 0:
#                 ready = True
#         except Exception as e:
#             log.error(e)


def rollout_restart():
    log.info('Restarting deployments...')
    for ns in ['kubeflow', 'auth', 'knative-serving', 'knative-eventing']:
        cmd = f'kubectl rollout restart deployments -n {ns}'.split()
        run_shell_cmd(cmd)
        

def config(args):
    log.debug(args)
    if hasattr(args, 'no_prompts'):
        no_prompts = args.no_prompts
    else:
        no_prompts = True
    env_file = args.env_file
    env = parse_kubeflow_env(env_file)
    env_template = parse_kubeflow_env(ENV_FILE_TEMPLATE)
    add_ons = get_add_ons()
        
    kf_version = versions.get('KUBEFLOW_RELEASE_VERSION')
    get_upstream(kf_version)
    validate_kubectl()
    validate_kustomize()
    validate_oci_cli()
    log.info('The following add-ons are defined in "./deployments/overlays/kustomization.yaml":')
    for add_on in add_ons:
        log.info(f'- {add_on}')
    log.info('To disable add-ons that are not desired, comment them out in the kustomization.yaml file above.')
    log.info('Validating add-on configuration...')
    validate_addons_config(add_ons, env_file, env, env_template, no_prompts)

    log.info('Configuring add-on templates...')
    deferred_tasks = []
    for add_on in add_ons:
        log.info(f'Add-on: {add_on}')
        if add_on == 'idcs':
            deferred = setup_idcs(env)
            if deferred:
                deferred_tasks.append(setup_idcs)
        elif add_on == 'letsencrypt-http01':
            setup_letsencrypt(env)
        elif add_on == 'letsencrypt-dns01':
            setup_dns_zone(env)
            setup_letsencrypt(env)
            deferred_tasks.append(setup_dns_post_deploy)
        elif add_on == 'oci-object-storage':
            setup_oci_object_storage(env)
        elif add_on == 'external-mysql':
            setup_mysql(env)
    log.info('Add-ons are configured')
    return deferred_tasks, env


def build(args):
    log.debug(args)
    deferred_tasks, env = config(args)
    try:
        output_dest = args.output
    except AttributeError:
        output_dest = None
    if output_dest is not None:
        kustomize_manifests(output_dest)
    return deferred_tasks, env


def deploy(args):
    log.debug(args)
    deferred_tasks, env = build(args)
    kustomize_and_apply()
    for func in deferred_tasks:
        func(env)
    log.debug(args.no_restart)
    if not args.no_restart:
        rollout_restart()


def user(args):
    log.debug(args)
    user_parser.print_help()


def user_create(args):
    email = args.email
    while email == '':
        email = input('User Email:')
        log.debug(email)
        email = email.strip()
    username = args.username
    while username == '':
        username_default = re.sub(r'[@_.]', '-', email)
        username = input(f'Username/Namespace (defaults to {username_default}): ')
        username = username.strip()
        if username == '':
            username = username_default
    match = re.match(r'^[a-z0-9-]+$', username)
    log.debug(match)
    if match is None:
        log.error(f'username must comply with Kubernetes namespace naming pattern [a-z0-9-]+')
        exit(1)
    # check is namespace exists
    cmd = f'kubectl get ns {username}'.split()
    try:
        Popen(cmd, shell=False, stdout=PIPE)
        log.error(f'The username / namespace "{username}" already exists.')
        exit(1)
    except subprocess.CalledProcessError:
        pass
    env_vars = {
        'EMAIL': email,
        'USERNAME': username
    }
    cwd = os.getcwd()
    template_path = os.path.join(*['oci', 'profile', 'user-profile.tmpl.yaml'])
    rendered_path = os.path.join(cwd, *['oci', 'profile', f'{email}.Profile.yaml'])
    render_template(env_vars, template_path, rendered_path)
    cmd = f'kubectl apply -f {rendered_path}'.split() 
    run_shell_cmd(cmd)
    if args.kfp:
        kfp_template = os.path.join(cwd, *['oci', 'profile', 'pod_defaults', 'access-kf-pipeline.PodDefault.yaml'])
        cmd = f'kubectl apply -f {kfp_template} -n {username}'.split() 
        run_shell_cmd(cmd)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='OCI KubeFlow CLI',
                                    usage="./okf COMMAND [FLAGS]")

    # parser.add_argument('--env_file', '-e', help='environment variables file to use (defaults to "kubeflow.env")', default=ENV_FILE)
    parser.add_argument('--debug', '-d', help='set log level to DEBUG', action='store_true')

    subparsers = parser.add_subparsers(title='commands',
                                   description='valid subcommands',
                                   help="""
config: configure add-ons required variables and generate add-on manifests files.\n
build: configure add-ons and build manifests to file. Use if intermediate manifest files are needed.\n
deploy: configure, build manifests and deploy, without intermediate files.\n
user: manager user profiles.
""")
    config_parser = subparsers.add_parser('config')
    config_parser.add_argument('--no-prompts', '-n', help='fails on missing values. Defaults to prompting for missing values', action='store_true')
    config_parser.add_argument('--env_file', '-e', help='environment variables file to use (defaults to "kubeflow.env")', default=ENV_FILE)
    config_parser.add_argument('--debug', '-d', help='set log level to DEBUG', action='store_true')
    config_parser.set_defaults(func=config)
    
    build_parser = subparsers.add_parser('build', usage="""
    the build command is used to build manifests to file. It requires an output path or folder. 
    Use -o <output file | folder> or use 'okf deploy' to build and deploy without intermediate files.
    """)
    build_parser.add_argument('--output', '-o', help='output file or folder. If an existing folder is provided, generate individual manifests, as kustomize does.', required=True)
    build_parser.add_argument('--env_file', '-e', help='environment variables file to use (defaults to "kubeflow.env")', default=ENV_FILE)
    build_parser.add_argument('--debug', '-d', help='set log level to DEBUG', action='store_true')
    build_parser.set_defaults(func=build)

    deploy_parser = subparsers.add_parser('deploy', usage="""
    the deploy command configures add-ons, builds manifests and deploys.
    """)
    deploy_parser.add_argument('--env-file', '-e', dest='env_file', help='environment variables file to use (defaults to "kubeflow.env")', default=ENV_FILE)
    deploy_parser.add_argument('--debug', '-d', help='set log level to DEBUG', action='store_true')
    deploy_parser.add_argument('--no-restart', '-n', dest='no_restart', help='disable forced rollout restart of the deployment to insure istio-sidecars are activated.', action='store_true', default=False)
    deploy_parser.set_defaults(func=deploy)

    user_parser = subparsers.add_parser('user', usage="""
    ./okf user COMMAND
    """, description='the user command provides utilities to manage user namespaces.')
    user_parser.add_argument('--debug', '-d', help='set log level to DEBUG', action='store_true')
    user_parser.set_defaults(func=user)

    user_subparsers = user_parser.add_subparsers(title='subcommands',
                                   description='valid subcommands',
                                   help='see each command\'s help for additional help')

    user_create_parser = user_subparsers.add_parser('create', usage="""
    okf user create -E email -U username
    """)
    user_create_parser.add_argument('--debug', '-d', help='set log level to DEBUG', action='store_true')
    user_create_parser.add_argument('--email', '-E', dest='email', help='user email', default='')
    user_create_parser.add_argument('--username', '-U', help='username', default='')
    user_create_parser.add_argument('--kpf', dest='kfp', help='enable access to KubeFlow Pipelines in notebooks', action='store_true', default=False)
    user_create_parser.set_defaults(func=user_create)

    args = parser.parse_args()
    log_level = logging.DEBUG if args.debug else logging.INFO
    log.setLevel(log_level)
    log.debug(args)


    versions = parse_versions_file()

    try:
        log.debug(args.func)
        # call submodule
        args.func(args)
    except AttributeError as e:
        log.debug(e)
        parser.print_help()
